"""
Convert binary mask PNGs to YOLO segmentation polygon format.

This script:
1. Reads binary masks per class (generated by export_slices.py)
2. Finds connected components per class
3. Extracts contours using OpenCV
4. Simplifies polygons using approxPolyDP
5. Normalizes coordinates to [0, 1]
6. Writes YOLO format: class_id x1 y1 x2 y2 ... xn yn
"""

import sys
from pathlib import Path
from typing import List, Tuple, Optional

import cv2
import numpy as np
from tqdm import tqdm


def find_contours_from_mask(
    mask: np.ndarray,
    min_area: int = 50,
) -> List[np.ndarray]:
    """
    Find contours from a binary mask.

    Args:
        mask: Binary mask (0 or 255)
        min_area: Minimum contour area to keep (default: 50 pixels)

    Returns:
        List of contours (each contour is Nx2 array of points)
    """
    # Ensure binary mask
    _, binary = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)

    # Find contours
    contours, hierarchy = cv2.findContours(
        binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )

    # Filter by area
    valid_contours = []
    for contour in contours:
        area = cv2.contourArea(contour)
        if area >= min_area:
            valid_contours.append(contour)

    return valid_contours


def simplify_contour(
    contour: np.ndarray,
    epsilon_factor: float = 0.001,
) -> np.ndarray:
    """
    Simplify contour using Douglas-Peucker algorithm.

    Args:
        contour: Input contour (Nx1x2 array from OpenCV)
        epsilon_factor: Approximation accuracy as fraction of perimeter (default: 0.001)

    Returns:
        Simplified contour
    """
    perimeter = cv2.arcLength(contour, closed=True)
    epsilon = epsilon_factor * perimeter
    approx = cv2.approxPolyDP(contour, epsilon, closed=True)
    return approx


def contour_to_normalized_polygon(
    contour: np.ndarray,
    image_width: int,
    image_height: int,
) -> List[float]:
    """
    Convert contour to normalized polygon coordinates.

    Args:
        contour: OpenCV contour (Nx1x2 array)
        image_width: Image width in pixels
        image_height: Image height in pixels

    Returns:
        Flattened list of normalized coordinates [x1, y1, x2, y2, ...]
    """
    # Reshape contour to Nx2
    points = contour.reshape(-1, 2)

    # Normalize to [0, 1]
    normalized = []
    for x, y in points:
        norm_x = float(x) / image_width
        norm_y = float(y) / image_height
        # Clip to [0, 1] to handle edge cases
        norm_x = np.clip(norm_x, 0.0, 1.0)
        norm_y = np.clip(norm_y, 0.0, 1.0)
        normalized.extend([norm_x, norm_y])

    return normalized


def convert_mask_to_yolo_polygons(
    mask_path: Path,
    class_id: int,
    min_area: int = 50,
    epsilon_factor: float = 0.001,
) -> List[str]:
    """
    Convert a single class mask to YOLO polygon format lines.

    Args:
        mask_path: Path to binary mask PNG
        class_id: YOLO class ID (0-indexed)
        min_area: Minimum contour area in pixels
        epsilon_factor: Polygon simplification factor

    Returns:
        List of YOLO format strings (one per instance/contour)
    """
    # Read mask
    mask = cv2.imread(str(mask_path), cv2.IMREAD_GRAYSCALE)
    if mask is None:
        return []

    height, width = mask.shape

    # Find contours
    contours = find_contours_from_mask(mask, min_area)

    # Convert each contour to YOLO format
    yolo_lines = []
    for contour in contours:
        # Simplify polygon
        simplified = simplify_contour(contour, epsilon_factor)

        # Skip if too few points after simplification
        if len(simplified) < 3:
            continue

        # Normalize coordinates
        normalized = contour_to_normalized_polygon(simplified, width, height)

        # Format: class_id x1 y1 x2 y2 ... xn yn
        coords_str = " ".join([f"{coord:.6f}" for coord in normalized])
        yolo_line = f"{class_id} {coords_str}"
        yolo_lines.append(yolo_line)

    return yolo_lines


def process_slice(
    slice_name: str,
    masks_dir: Path,
    labels_dir: Path,
    class_mapping: dict,
    min_area: int = 50,
    epsilon_factor: float = 0.001,
) -> int:
    """
    Process all class masks for a single slice and create YOLO label file.

    Args:
        slice_name: Slice identifier (e.g., "patient001_slice0005")
        masks_dir: Directory containing mask PNGs
        labels_dir: Output directory for YOLO label TXT files
        class_mapping: Dict mapping class numbers to YOLO class IDs
        min_area: Minimum contour area
        epsilon_factor: Polygon simplification factor

    Returns:
        Number of polygons written
    """
    all_yolo_lines = []

    # Process each class
    for class_num, yolo_class_id in class_mapping.items():
        mask_path = masks_dir / f"{slice_name}_class{class_num}.png"

        if not mask_path.exists():
            continue

        # Convert mask to YOLO polygons
        yolo_lines = convert_mask_to_yolo_polygons(
            mask_path, yolo_class_id, min_area, epsilon_factor
        )
        all_yolo_lines.extend(yolo_lines)

    # Write YOLO label file
    if all_yolo_lines:
        label_path = labels_dir / f"{slice_name}.txt"
        with open(label_path, "w") as f:
            f.write("\n".join(all_yolo_lines))

    return len(all_yolo_lines)


def main():
    """CLI entry point for mask to YOLO conversion."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Convert binary masks to YOLO polygon format"
    )
    parser.add_argument(
        "--data_dir",
        type=Path,
        default=Path("data/derivatives/yolo_sagittal"),
        help="Data directory containing masks/ and images/ (default: data/derivatives/yolo_sagittal)",
    )
    parser.add_argument(
        "--splits",
        nargs="+",
        default=["train", "val", "test"],
        help="Dataset splits to process (default: train val test)",
    )
    parser.add_argument(
        "--min_area",
        type=int,
        default=50,
        help="Minimum contour area in pixels (default: 50)",
    )
    parser.add_argument(
        "--epsilon_factor",
        type=float,
        default=0.001,
        help="Polygon simplification factor (default: 0.001)",
    )

    args = parser.parse_args()

    # Class mapping: mask class number -> YOLO class ID
    # Based on your classes:
    # 1: vertebra    -> class 0
    # 2: ivf         -> class 1
    # 3: sacrum      -> class 2
    # 4: spinal_canal -> class 3
    class_mapping = {
        1: 0,  # vertebra
        2: 1,  # ivf
        3: 2,  # sacrum
        4: 3,  # spinal_canal
    }

    print("=" * 70)
    print("Convert Binary Masks to YOLO Polygon Format")
    print("=" * 70)
    print(f"Data directory: {args.data_dir.absolute()}")
    print(f"Class mapping: {class_mapping}")
    print(f"Min area: {args.min_area} pixels")
    print(f"Epsilon factor: {args.epsilon_factor}")
    print("=" * 70)

    total_stats = {"slices": 0, "polygons": 0}

    for split in args.splits:
        masks_dir = args.data_dir / "masks" / split
        images_dir = args.data_dir / "images" / split
        labels_dir = args.data_dir / "labels" / split

        # Skip if no masks directory
        if not masks_dir.exists():
            print(f"\nSkipping {split}: masks directory not found")
            continue

        # Create labels directory
        labels_dir.mkdir(parents=True, exist_ok=True)

        # Find all unique slice names from image files
        image_files = sorted(images_dir.glob("*.png"))
        slice_names = [img.stem for img in image_files]

        if not slice_names:
            print(f"\nSkipping {split}: no images found")
            continue

        print(f"\n{'=' * 70}")
        print(f"Processing {split.upper()} split ({len(slice_names)} slices)")
        print(f"{'=' * 70}")

        split_polygon_count = 0

        for slice_name in tqdm(slice_names, desc=f"{split} slices"):
            n_polygons = process_slice(
                slice_name,
                masks_dir,
                labels_dir,
                class_mapping,
                args.min_area,
                args.epsilon_factor,
            )
            split_polygon_count += n_polygons

        print(f"  ✓ Created {len(slice_names)} label files")
        print(f"  ✓ Total polygons: {split_polygon_count}")

        total_stats["slices"] += len(slice_names)
        total_stats["polygons"] += split_polygon_count

    # Summary
    print("\n" + "=" * 70)
    print("Conversion Summary")
    print("=" * 70)
    print(f"Total slices processed: {total_stats['slices']}")
    print(f"Total polygons created: {total_stats['polygons']}")
    print(f"Average polygons per slice: {total_stats['polygons'] / max(total_stats['slices'], 1):.1f}")
    print("=" * 70)


if __name__ == "__main__":
    main()